# Task 1 - Message Storage and Retrieval

### Arrays
Arrays are a very simple but limited data structure. It is very efficient but it requires that the data has a fixed number of elements known and doesn't change. When we start to think about the application with messages, sending and retrieving them, it is a question of whether or not we know what exactly is being sent. If it is something like a script where we know exactly how many lines are going to be sent, when they are going to be sent and the order, then it *could* be useful. While it is efficient I do not believe that it is the most sustainable format to retrieve messages. The challenge comes when you need to know the exact index of the message in order to find that message. Another challenge comes when you need to add or remove messages, setting up an operation to do these tasks are much less efficient than other data structures. An example of a good use case for this data structure would be displaying a list of messages in the exact order that they were recieved.

### Linked Lists
Linked lists are an improvement when we look at another data structure like arrays. This data structure allows us to dynamically grow or shrink the elements without needing to resize the entire thing. Adding or removing elements can be efficient when it is at the end or start of the structure but some efficiency challenges begin to appear when we start to add or remove them from the middle of the structure. Unlike arrays, Linked lists do not require contiguous memory. Some of the weaknesses of linked lists come when are accessing an element in the middle of the list. It requires us to travel from the head node causing the execute time to take longer according to the Big O. Another issue we may run into is linked lists require some additional memory when we start appointing pointers to our functions. Linked lists are also more complex and more challenging when compared to other data structures like arrays. Some of the usefulness of linked lists comes when an application requires very frequent insertion or removal of elements if the size of the dataset is everchanging. An example of a use case would be a constant flow of messages, where new messeges are actively added or deleted.

### Hash Tables
Hash tables uses a *hashing* system that computes an index for each key, At each key there is a corresponding value that is stored. Hash tables use a unique *chaining* techinique or *open addressing* to solve issues like hash collisions (two keys hashing to the same index). Thanks to its efficient hashing insertion, removal, and lookup operations are very efficient thanks to its efficient hashing system. Allows for a better workflow with its storing and retrieving functions with its meaningful keys like the messege senders IDs. This data structure can resize fairly efficiently albeit comes with a cost. Performance of this structure can struggle if the data stored inside of it is held at the same index. It also struggles being an unordered form of data storage. Due to it requiring a hash table and collision handling, it causes an increase in the amount of memory necessary. Use cases for this structure include applications that require fast lookups and data storage that requires unique keys. With our example we could use this data structure could be used to store messages that are mapped to unique IDs or timestamps.

### Trees
Trees use a hierarchial data structure that is built of many nodes. Each node has a parent that can have multiple children. A binary tree which was talked about in this lesson is a common type where each node can have up to 2 children at most. With our binary search tree (BST) it makes sure that the left child is smaller and the right cild is larger of the parent allowing us to search more efficiently. BSTs maintain sorted order so it makes them ideal for range-based queries. Using this data structure allows us to create efficient operations for insterting, removing, and searching for messages. Some challenges that we may face using this structure include keeping the tree balanced which requires additional operations, searching through all the nodes can take much more time which can be slower than other structures like hash tables, and memory usage can get a bit overbearing when pointers get involved. A good use case for trees would be storing data that is accessed in a sorted order. An example of how we could use this is organizing messages chronologically.

# Task 2 - Real-Time Updates

### Polling
Polling is where a client repeatedly sends HTTP requests to a server at regular intervals set (example: every few seconds) to check for updates. With each update the request will grab the largest data, even if no changes were made. Polling is very simple to implement using standard HTTP protocols. It is stateless and works with REST APIs without requiring additional infrastructure. Some of the downsides when using polling include its innefficiency of requests when there is no new data to update, It's inablilty to provide "real-time" updates due to it's requirement of providing a polling interval, and server load with high request frequency. Some applications where this can be useful are stocks where they don't require real time updates but updates in a set interval.

### Long-Polling
An "update" to polling where long polling will keep the client connection open until the server recieves new data or is timed out. The way it works is the server sends a response and the client will send another request right away maintaining a constant communication loop. Some advantages of using this include its efficiency due to it making less redundant requests when no new data is available to update and a wider support of other technologies that don't require WebSocket support. Some disadvantages of long polling include it's response delays during high traffic times due to it still using HTTP requests and it's requirement to maintain open HTTP connections for many clients which can strain server resources. Some use cases for long polling include real-time notification or chat systems.

### WebSockets
WebSockets establish a full-duplex communication channel between the client and server over a single and constant TSP connection. After an initial HTTP connection, WebSockets allow us to have bidirectional communication which means either the client or the server can push for an update at any time without additional requets. Some advantages of using this are real-time updates are instant so data can be pushed from server to client as soon as possible, avoids the requirement of multiple HTTP requests by keep one connection open, and it's two way communication because both the client and server can send messeges. Some disadvantages of this are its complexity that requires more advanced server infrastructure and firewall issues where it will be blocked or proxies that don't support WebSockets. Some use cases for WebSockets include multiplayer games, live chat, and sports score updates. 

# Task 3 - Conversation List Management

### Arrays
Arrays use contiguous blocks of memery where the data that is stored is stored in a way that is sequential and access to the data is done through indexing. Some of the advantages to using this include constant-time access if you know the index of the data you are trying to access and it's simple iteration. Some downsides to using this include it's reliablity of knowing the size or you are forced to resize the capacity and its expensive operations esspecially for altering positions in the middle of the metadata. A use case for this would be displaying a conversation in chronological order. 

### Linked Lists
Linked lists consists of nodes where each node contains the data and a reference to the next node. It's ability to adjusts it's size makes it useful along with tis efficiency in making modifications to the beginning or end. It struggles when trying to find a specific node and eits requirement for extra memory when storing pointers. A good use case for this is a data structure for conversations where you need frequent updates or removals of messages.

### Hash Tables
Hash tables functionality allows use to map keys to values for storing information. It's strengths rely in it's ability to create fast access for operations like searching, inserting, and removing data. It's also praised for it's flexibility in storing non-sequential metadata. It begins to struggle when we start running into hash collisions which can ruin it's performance. It also runs into trouble with it's unordered nature making it not ideal for storing sequences. A good use case for this is when a large system needs to retrieve the data from a key like a messaging app that stores user specific conversations.

### Trees
Trees use its hierarchial data structure where each node has a parent and multiple children. It's perfect for modeling relationships due to its hierarchial nature. It's sorted making it useful for certain queries like range queries. Different variants like B-trees allow us to ensure balanced structures allowing for consistant performance. It begins to struggle with its complexity and it can be slower if the trees are not balanced. A good use case for this would be something like reddit where there are threaded discussions.